#include <Encoder.h>
#include "U8glib.h"
#include <OneButton.h>
#include <Servo.h>

#define BUTTON1_PIN 11
#define BUTTON2_PIN 4
#define TRIGGER_PIN 12
#define ECHO_PIN 10
#define BUZZ_PIN 8
#define LED_PIN 6
#define SERVO_PIN 9
#define BLUE_PIN 6
#define GREEN_PIN 5
Encoder myEnc(2, 3);
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE);
OneButton button1(BUTTON1_PIN, true, true);
OneButton button2(BUTTON2_PIN, true, true);
Servo voltagePointer;

const char *menuItems[] = {"Range", "Volt", "Oscilloscope", "Music", "Flashlight"};
const int menuCount = 5;
int selectedIndex = 0;
bool inMenu = false;
bool showWelcome = true;
bool showMenuHint = false;
unsigned long menuHintTime = 0;
const unsigned long menuHintDuration = 4000;
const long pulsesPerRevolution = 390;

int md = 15;
int flag = 1;
unsigned long cur = 0, curr = 0, currr = 0;
int change = 0;
int bluestat = 0;
int i = 0, step = 5;
long newpos = 0, oldpos = 0;

#define BUF_SIZE 64
float voltageBuffer[BUF_SIZE];
int bufferIndex = 0;
const int X_ORIGIN = 64;
const int Y_ORIGIN = 40;
int currentChannel = 0;
const int analogPins[3] = {A0, A1, A2};
bool isPlaying = false;
int currentNoteIndex = 0;
int currentSong = 0;
struct Note { int frequency; unsigned long duration; };
Note song2[] = {{784,600},{784,300},{880,300},{587,1200},{523,600},{523,300},{440,300},{587,1200},{784,600},{784,600},{880,300},{1046,300},{880,300},{784,300},{523,600},{523,300},{440,300},{587,1200}};
Note song1[] = {{440,300},{392,300},{440,300},{392,900},{440,300},{659,600},{659,300},{0,300},{659,300},{587,300},{523,300},{587,300},{523,600},{523,300},{523,300},{440,600},{440,300},{392,900}};
Note* songs[] = {song1, song2};
const int songCount = sizeof(songs)/sizeof(songs[0]);
const int songNotes[] = {sizeof(song1)/sizeof(Note), sizeof(song2)/sizeof(Note)};

int flashlightFlag = 1;

void draw3DMenu() {
  u8g.firstPage();
  do {
    button1.tick();
    u8g.setColorIndex(0);
    u8g.drawBox(0, 0, 128, 64);
    u8g.setColorIndex(1);
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(5, 10, menuItems[selectedIndex]);
    
    for(int i = 0; i < menuCount; i++) {
      button1.tick();
      int offsetX = (i - selectedIndex) * 30;  
      int scale = 100 - abs(i - selectedIndex) * 20;
      int boxWidth = u8g.getStrWidth(menuItems[i]) + 10; 
      int boxHeight = 16;
      int x = 64 + offsetX - (boxWidth * scale/100)/2;
      int y = 32 - (boxHeight * scale/100)/2;
      int w = boxWidth * scale/100;
      int h = boxHeight * scale/100;
      if(i == selectedIndex) {
        u8g.drawBox(x, y, w, h);
        u8g.setColorIndex(0); 
      } else {
        u8g.drawFrame(x, y, w, h);
        u8g.setColorIndex(1);
      }
      u8g.setFont(u8g_font_6x10);
      int textX = x + (w - u8g.getStrWidth(menuItems[i]))/2;
      int textY = y + h/2 + 4;
      u8g.drawStr(textX, textY, menuItems[i]);
      u8g.setColorIndex(1);
    }
  } while(u8g.nextPage());
}

void drawWelcomeScreen() {
  u8g.firstPage();
  do {
    u8g.setColorIndex(1);
    u8g.setFont(u8g_font_10x20);
    u8g.drawStr(15, 30, "Welcome!");
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(10, 50, "Smart Device System");
  } while(u8g.nextPage());
}

void drawMenuHint() {
  u8g.firstPage();
  do {
    button1.tick();
    u8g.setColorIndex(1);
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(10, 20, "Long press button");
    u8g.drawStr(20, 40, "to enter menu");
    u8g.drawStr(1, 60, "Double click to select");
  } while(u8g.nextPage());
}



void drawDistanceScreen(int distance) {
  u8g.firstPage();
  do {
    button1.tick();
    u8g.setFont(u8g_font_10x20);
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(0, 10, flag ? "[Threshold Mode]" : "[Measuring Mode]");
    u8g.setFont(u8g_font_10x20);
    u8g.drawStr(20, 35, "Dist:");
    u8g.setPrintPos(80, 35);
    if(distance <= 0) {
      u8g.print("---");
    } else {
      u8g.print(distance);
      u8g.print("cm");
    }
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(0, 55, "Threshold:");
    u8g.setPrintPos(60, 55);
    u8g.print(md);
    u8g.print("cm");
  } while(u8g.nextPage());
}

long getDistance() {
  pinMode(TRIGGER_PIN, OUTPUT);
  digitalWrite(TRIGGER_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIGGER_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);
  pinMode(ECHO_PIN, INPUT);
  long duration = pulseIn(ECHO_PIN, HIGH);
  return duration * 0.034 / 2;
}
void onLongPress() {
  flag = !flag;
  Serial.println(flag);
  //Serial.println(flag ? "Enter Threshold Mode" : "Exit Threshold Mode");
}

void rangeFinderMode() {
  button2.tick();
  int c = getDistance();
  drawDistanceScreen(c);
  if(flag==1) { 
    digitalWrite(BLUE_PIN, 0);
    analogWrite(GREEN_PIN, 0);
    while(true) {
      button2.tick();
      if(flag==0) break;
      
      drawDistanceScreen(c);
      
      if(md>=10 && md<=50) {
        newpos = myEnc.read();
        int angle = fmod((newpos * 360.0 / (5*pulsesPerRevolution)), 360);
        if(angle<0) {
          change=map(angle,-360,0,-30,0);
        } else if(angle>0) {
          change=map(angle,0,360,0,35);
        }
      } else if(md<10) md=10;
      else if(md>50) md=50;
      
      if(millis()-currr>2000) {
        myEnc.write(0);
        currr=millis();
        md+=change;
        change=0;
        //Serial.println(md);
      }

      if(millis()-cur>10) {
        i=i+step;
        analogWrite(BLUE_PIN,i);
        if(i==255) step=-step;
        if(i==0) step=-step;
        cur=millis();
      }
    }
  }
  if(flag==0) { 
      button2.tick();
      int c = getDistance();
      drawDistanceScreen(c);
      if(c>md) {
        while(true){
          int c = getDistance();
          drawDistanceScreen(c);
          button2.tick();
          analogWrite(GREEN_PIN,100);
          analogWrite(BLUE_PIN,0);
          if(c>md) break;
          if(flag==1) break;
        }
      } 
      else if(c<md) {
        analogWrite(GREEN_PIN,0);
        while(true) {
          button2.tick();
          int c=getDistance();
          drawDistanceScreen(c);
          if(c>md) break;
          if(millis()-curr>80) {
            bluestat=!bluestat;
            digitalWrite(BLUE_PIN,bluestat);
            curr=millis();
          }
        }
      }
    }
  }

void onClick() {
  currentChannel = (currentChannel + 1) % 3;
  Serial.println(currentChannel);
}

void drawAxesWithArrows() {
  u8g.drawHLine(X_ORIGIN, Y_ORIGIN, 64);
  u8g.drawLine(X_ORIGIN+64, Y_ORIGIN, X_ORIGIN+60, Y_ORIGIN-3);
  u8g.drawLine(X_ORIGIN+64, Y_ORIGIN, X_ORIGIN+60, Y_ORIGIN+3);
  u8g.drawVLine(X_ORIGIN, Y_ORIGIN-20, 40);
  u8g.drawLine(X_ORIGIN, Y_ORIGIN-20, X_ORIGIN-3, Y_ORIGIN-16);
  u8g.drawLine(X_ORIGIN, Y_ORIGIN-20, X_ORIGIN+3, Y_ORIGIN-16);
  u8g.drawPixel(X_ORIGIN, Y_ORIGIN);
}

void drawOscilloscope() {
  u8g.firstPage();
  do {
    button2.tick();
    u8g.setColorIndex(1);
    u8g.setFont(u8g_font_6x10);
    u8g.drawStr(35, 10, "Oscilloscope");
    drawAxesWithArrows();
    
    for(int i=1; i<BUF_SIZE; i++) {
      int prevX = X_ORIGIN + i-1;
      int currX = X_ORIGIN + i;
      int prevY = map(voltageBuffer[i-1], 0, 5, Y_ORIGIN+20, Y_ORIGIN-20);
      int currY = map(voltageBuffer[i], 0, 5, Y_ORIGIN+20, Y_ORIGIN-20);
      u8g.drawLine(prevX, prevY, currX, currY);
    }
    
    u8g.setFont(u8g_font_5x8);
    u8g.setPrintPos(5, 63);
    u8g.print("A");
    u8g.print(currentChannel);
  } while(u8g.nextPage());
}

void oscilloscopeMode() {
  button2.tick();
  voltageBuffer[bufferIndex] = analogRead(analogPins[currentChannel]) * (5.0 / 1023.0);
  bufferIndex = (bufferIndex + 1) % BUF_SIZE;
  drawOscilloscope();
  delay(50);
}

float readVoltage() {
  float sum = 0;
  for(int i = 0; i < 10; i++) {
    sum += analogRead(A0);
    delay(5);
  }
  return (sum / 10) * (5.0 / 1023.0);
}

void drawVoltageDisplay(float voltage) {
  u8g.firstPage();
  do {
    u8g.setFont(u8g_font_10x20);
    u8g.drawStr(0, 10, "Voltage Meter");
    char voltageStr[10];
    dtostrf(voltage, 5, 2, voltageStr);
    u8g.drawStr(20, 35, voltageStr);
    u8g.drawStr(80, 35, "V");
  } while(u8g.nextPage());
}

void updateServo(float voltage) {
  int angle = map(voltage * 100, 0, 500, 170, 10);
  angle = constrain(angle, 10, 170);
  voltagePointer.write(angle);
}

void voltageMeterMode() {
  float voltage = readVoltage();
  drawVoltageDisplay(voltage);
  updateServo(voltage);
  delay(200);
}
void togglePlayback() {
  isPlaying = !isPlaying;
  if(isPlaying) {
    Serial.print("Resume song ");
    Serial.print(currentSong + 1);
    Serial.print(" note ");
    Serial.println(currentNoteIndex);
  } else {
    noTone(BUZZ_PIN);
    Serial.println("Paused");
  }
}

void switchSong() {
  noTone(BUZZ_PIN);
  currentSong = (currentSong + 1) % songCount;
  currentNoteIndex = 0;
  isPlaying = true;
}

void playCurrentNote() {
  static unsigned long noteStartTime = 0;
  static bool isNotePlaying = false;
  
  if(!isNotePlaying) {
    tone(BUZZ_PIN, songs[currentSong][currentNoteIndex].frequency);
    noteStartTime = millis();
    isNotePlaying = true;
  } else if(millis() - noteStartTime >= songs[currentSong][currentNoteIndex].duration) {
    noTone(BUZZ_PIN);
    isNotePlaying = false;
    currentNoteIndex++;
    if(currentNoteIndex >= songNotes[currentSong]) {
      currentNoteIndex = 0;
      delay(2000);
    }
  }
}

void musicPlayerMode() {
  button2.tick();
  if(isPlaying) {
    playCurrentNote();
  }
}

void flashlightOnLongPress() {
  flashlightFlag = !flashlightFlag;
}

void flashlightMode() {
  button2.tick();
  if(flashlightFlag == 1) {
    while(true) {
      button1.tick();
      button2.tick();
      if(flashlightFlag==0){
        break;
      }
      for(int i=0; i<=255; i+=5) {
        button2.tick();
        analogWrite(LED_PIN, i);
        delay(10);
      }
      for(int i=255; i>=0; i-=5) {
        button2.tick();
        analogWrite(LED_PIN, i);
        delay(10);
      }
    }
  }
  else{
    analogWrite(LED_PIN, 200);
  }
}

void enterMenu() {
  inMenu = true;
  showWelcome = false;
  showMenuHint = false;
  flag = 1;
  isPlaying = false;
  flashlightFlag = 0;
  noTone(BUZZ_PIN);
  analogWrite(LED_PIN, 0);
  analogWrite(BLUE_PIN, 0);
  analogWrite(GREEN_PIN, 0);
}

void exitMenu() {
 inMenu = false;
  showMenuHint=false;
 // showWelcome=false;
}
void selectMenuItem() {
  Serial.println("xxx");
  exitMenu();
}
void setup() {
  Serial.begin(9600);
  pinMode(BLUE_PIN, OUTPUT);
  pinMode(GREEN_PIN, OUTPUT);
  pinMode(BUZZ_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);
  voltagePointer.attach(SERVO_PIN);
  button1.attachLongPressStart(enterMenu);
  button1.attachDoubleClick(selectMenuItem);
  button2.attachLongPressStart(onLongPress);
  button2.attachClick(onClick);
  button2.attachDoubleClick(flashlightOnLongPress);
  drawWelcomeScreen();
  delay(4000);
  showWelcome = false;
  showMenuHint = true;
  menuHintTime = millis();
}

void loop() {
  button1.tick();
  
  if(showWelcome) {
    drawWelcomeScreen();
  } 
  else if(showMenuHint) {
    drawMenuHint();
    if(millis() - menuHintTime > menuHintDuration) {
      showMenuHint = false;
    }
  } 
  else if(inMenu) {
    draw3DMenu();
    long encoderPos = myEnc.read();  
    int angle = fmod((encoderPos * 360.0 / (3*pulsesPerRevolution)), 360);
    if(angle < 0) angle += 360; 
    
    if(angle>=0&&angle<72) selectedIndex=0;
    else if(angle>=72&&angle<144) selectedIndex=1;
    else if(angle>=144&&angle<216) selectedIndex=2;
    else if(angle>=216&&angle<288) selectedIndex=3;
    else if(angle>=288&&angle<=360) selectedIndex=4;
  } 
  else {
    switch(selectedIndex) {
      case 0: 

        button2.reset();
        button2.attachLongPressStart(onLongPress); 
        rangeFinderMode(); 
        break;
        
      case 1: 
        button2.reset();
        voltageMeterMode(); 
        break;
        
      case 2: 
        
        //button2.reset();
        button2.attachClick(onClick);
        oscilloscopeMode(); 
        break;
        
      case 3: 
        //button2.reset();
        button2.attachClick(togglePlayback);
        button2.attachLongPressStart(switchSong);
        musicPlayerMode(); 
        break;
        
      case 4: 
        //button2.reset();
        button2.attachDoubleClick(flashlightOnLongPress);
        flashlightMode(); 
        break;
    }
  }
  
  delay(10);
}
